# 介绍
>https://blog.csdn.net/xlgen157387/article/details/79530877 [缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题]

## 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题

    1.缓存雪崩：
        =================================================================
        【缓存同一时间大面积失效导致同时打到数据库致使宕机】
        【1.为key设置随机缓存时间：：setRedis（Key，value，time + Math.random() * 10000）】
        【2.加缓存标记：：存两份，做脏读，一份为标准有效时间，一份多加5-10分钟，第一份的过期的同时，去通知更新缓存，此时进来的请求做脏读，读取第二份中的数据】
        =================================================================
        解释：由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，
            而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃
        解决：
            1.加锁或者排队保证不会有大量线程同时对数据库进行读写 
                【并发量不多，加锁排队】
                【并发量大的时候，加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。
                    同样会导致用户等待超时，这是个治标不治本的方法！ 加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，
                    这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！】
                //伪代码
                public object GetProductListNew() {
                    int cacheTime = 30;
                    String cacheKey = "product_list";
                    String lockKey = cacheKey;
                
                    String cacheValue = CacheHelper.get(cacheKey);
                    if (cacheValue != null) {
                        return cacheValue;
                    } else {
                        synchronized(lockKey) {
                            cacheValue = CacheHelper.get(cacheKey);
                            if (cacheValue != null) {
                                return cacheValue;
                            } else {
                	            //这里一般是sql查询数据
                                cacheValue = GetProductListFromDB(); 
                                CacheHelper.Add(cacheKey, cacheValue, cacheTime);
                            }
                        }
                        return cacheValue;
                    }
                }
            2.给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存，实例伪代码如下：
                解释说明：
                1、缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存；
                2、缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端
                    ，直到另外的线程在后台更新完成后，才会返回新缓存。
                关于缓存崩溃的解决方法，这里提出了三种方案：使用锁或队列、设置过期标志更新缓存、为key设置不同的缓存失效时间，还有一各被称为“二级缓存”的解决方法，有兴趣的读者可以自行研究。
                //伪代码
                public object GetProductListNew() {
                    int cacheTime = 30;
                    String cacheKey = "product_list";
                    //缓存标记
                    String cacheSign = cacheKey + "_sign";
                
                    String sign = CacheHelper.Get(cacheSign);
                    //获取缓存值
                    String cacheValue = CacheHelper.Get(cacheKey);
                    if (sign != null) {
                        return cacheValue; //未过期，直接返回
                    } else {
                        CacheHelper.Add(cacheSign, "1", cacheTime);
                        ThreadPool.QueueUserWorkItem((arg) -> {
                			//这里一般是 sql查询数据
                            cacheValue = GetProductListFromDB(); 
                	        //日期设缓存时间的2倍，用于脏读
                	        CacheHelper.Add(cacheKey, cacheValue, cacheTime * 2);                 
                        });
                        return cacheValue;
                    }
                } 
    2.缓存穿透
        =================================================================
        【查询的数据，redis没有，数据库也没有，这样同一时间大量请求都会打到数据库导致宕机风险】
        【1.布隆过滤器-将所有可能存在的数据存储在bitmap，请求进来先过滤可能的请求】
        【2.将查询key为null的也存储在redis，下次继续查的时候，就不用在打到数据库，但是过期时间要设置短一点，30秒，要重新查询数据】
        【3.网关限制nginx限制对单个IP每秒访问次数超出阈值的IP都拉黑】
        =================================================================
        解释：查询无用数据，首先查询redis缓存不存在，接着去查询数据库，恶意攻击，大量无效数据打到数据库会造成宕机风险，也就是缓存命中率问题
        解决：
            1.布隆过滤器【常用】
                原理：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被bitmap拦截掉，从而避免宕机分析
            2.查询结果为空的数据依然存储在redis，防止下次继续查库，过期时间设置很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，
                这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴！
            3.把空结果，也给缓存起来，这样下次同样的请求就可以直接返回空了，即可以避免当查询的值为空时引起的缓存穿透。同时也可以单独设置个缓存区域存储空值，
                对要查询的key进行预先校验，然后再放行给后面的正常缓存处理逻辑。
    3.缓存击穿：
        =================================================================
        【热点数据，突然过期导致数据库突然打满】
        【1.做对象缓存，永不过期】
        【2.添加互斥锁 - 高可用和性能方面考虑的话，不建议】
        =================================================================
        解释：指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库
    4.缓存预热
        存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！
        解决：
            1.手动同步
            2.启动同步-项目启动自动加载
            3.定时刷新缓存
    5.缓存更新
        除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：
        （1）定时去清理过期的缓存；
        （2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。
        两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。
    6.缓存降级
        降级：就是在高并发高负载情况下，选择动态的关闭一下不重要的服务，拒绝访问等，来为重要的服务节省资源，比如电商平台秒杀当天可关闭推荐等功能
        当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。
        降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。
        在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：
        （1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
        （2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
        （3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
        （4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。
    6.限流：就相当于调整水龙头的大小，使得访问请求量控制在一定范围。
        对于比较关键又高并发的服务，比如秒杀，不能通过缓存和降级方式解决，至少不够解决太大并发量。这时候就需要限流了
        限流算法有：令牌桶、漏桶。计数器也可以进行粗暴限流实现。
        应用中的限流：比如TPS/QPS超过一定范围，进行控制，比如tomcat可配置可接受的等待连接数、最大连接数、最大线程数等。
        资源池化，然后超出限制等待请求资源数，就直接返回失败即可。
        接入层限流：指请求流量的入口，该层的主要目的有：负载均衡、非法请求过滤、请求聚合、缓存、降级、限流、A/B测试、服务质量监控等等。
        Nginx接入层限流可以使用Nginx自带了两个模块：连接数限流模块ngx_http_limit_conn_module和漏桶算法实现的请求限流模块ngx_http_limit_req_module
        限制每时每分每秒的访问请求数，可通过一个cacheMap<Long, AtomicLong>来实现，key为当前时间long值除以相应数。以下参考的实现，用Guava的Cache，设置过期时间，LFU最近最少使用的元素会被删除：
            LoadingCache<Long, AtomicLong> counter =  
                    CacheBuilder.newBuilder()  
                            .expireAfterWrite(2, TimeUnit.SECONDS)  
                            .build(new CacheLoader<Long, AtomicLong>() {  
                                @Override  
                                public AtomicLong load(Long seconds) throws Exception {  
                                    return new AtomicLong(0);  
                                }  
                            });  
            long limit = 1000;  
            while(true) {  
                //得到当前秒  
                long currentSeconds = System.currentTimeMillis() / 1000;  
                if(counter.get(currentSeconds).incrementAndGet() > limit) {  
                    System.out.println("限流了:" + currentSeconds);  
                    continue;  
                }  
                //业务处理  
            }  
    7.总结
        事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。
        事中：本地 ehcache 缓存 + Hystrix 限流+降级，避免MySQL 被打死。
        事后：Redis 持久化 RDB+AOF，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。
    
        
### 为什么说Redis是单线程的以及Redis为什么这么快！

    ·二八定律
    ·热数据，冷数据
    
    1.Redis是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。
        它支持多种类型的数据结构，如字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，
        Hyperloglogs 和地理空间（Geospatial）索引半径查询。其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。
    2.Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 
        和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。
    3.Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），
        或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。
    4.Redis不使用表，他的数据库不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。
    5.数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。
      
    6.redis到底有多快：
        Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。
        这个数据不比采用单进程多线程的同样基于内存的 KV 数据库 Memcached 差！有兴趣的可以参考官方的基准程序测试《How fast is Redis？》（https://redis.io/topics/benchmarks）
    7.为什么快？
        1.完全基于内存，没有磁盘io
        2.数据结构简单
        3.单线程，避免上下文切换和竞争，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
        4.使用多路I/O复用模型，非阻塞IO；
            多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，
            于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。
            **这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。**采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），
            且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量
        5.使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；
    8.为什么redis是单线程？
        官方：
            因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了
            （毕竟采用多线程会有很多麻烦！）
    9.使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善！
        警告1：这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！
            例如Redis进行持久化的时候会以子进程或者子线程的方式执行（具体是子线程还是子进程待读者深入研究）；例如我在测试服务器上查看Redis进程，然后找到该进程下的线程：
            ps -ef|grep redis 【查看进程id】
            ps -T -p 进程id   【查看进程下的线程】
            ps命令的“-T”参数表示显示线程（Show threads, possibly with SPID column.）“SID”栏表示线程ID，而“CMD”栏则显示了线程名称。
        警告2：在上图中FAQ中的最后一段，表述了从Redis 4.0版本开始会支持多线程的方式，但是，只是在某一些操作上进行多线程的操作！所以该篇文章在以后的版本中是否还是单线程的方式需要读者考证！
            
### redis怎么保证双写一致性
    
    1.最终一致性方案：- 【设置过期时间，不管更新操作，等过期后重新回填缓存即可】
        1.给缓存设置过期时间，是保证最终一致性的解决方案
        2.在这种方案下，可以对存入缓存的数据设置过期时间，索引的写操作以数据库为准，
            对缓存操作只是尽最大的努力。也就是说如果数据库写成功，缓存更新失败，那么只要达到过期时间，则后面的读请求自然会从数据库中读取新的值然后回填缓存
    2.先更新数据库，再更新缓存【反对】
        1.线程安全问题：这本该请求A先更新缓存，B后更新才对，但是因为网络等原因，B却比A更早更新了缓存，这就导致出现了脏数据，故不考虑
            1.1 线程A更新了数据库
            1.2 线程B更新了数据库
            1.3 线程B更新了缓存
            1.4 线程A更新了缓存
        2.写多读少的业务中，数据被频繁更新的问题，浪费性能
    3.先删除缓存，再更新数据库
        该方案会导致不一致的原因是：同时有一个请求A进行更新操作，另一个请求B进行查询操作，那么会出现以下几种情景：
        1、请求A进行写操作，删除缓存
        2、请求B进行读操作，发现缓存不存在
        3、请求B去数据库查询得到旧值
        4、请求B将旧值写入缓存
        5、请求A将新值写入数据库，这样的情况就会导致不一致的情形出现，而且，如果不采用给缓存设置过期时间，该数据永远都是脏数据
        采用延时双删策略
        1、先淘汰缓存
        2、再写数据库
        3、休眠1秒，再次淘汰缓存，可以将1秒内所造成的缓存脏数据再次删除
        那么，这个1秒怎么确定的，具体该休眠多久呢？
        针对上面的情形，应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。
        如果你用了mysql的读写分离架构怎么办？
        还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。
        （1）请求A进行写操作，删除缓存
        （2）请求A将数据写入数据库了，
        （3）请求B查询缓存发现，缓存没有值
        （4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值
        （5）请求B将旧值写入缓存
        （6）数据库完成主从同步，从库变为新值 上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。
        采用这种同步淘汰策略，吞吐量会降低，那又该怎么办呢？
        那可以将第二次删除作为异步，自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后再返回，这样做就可以加大吞吐量
        第二次删除,如果删除失败怎么办？
        这会出现下面的请求，一个A请求进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：
        1）请求A进行写操作，删除缓存
        （2）请求B查询发现缓存不存在
        （3）请求B去数据库查询得到旧值
        （4）请求B将旧值写入缓存
        （5）请求A将新值写入数据库
        （6）请求A试图去删除请求B写入对缓存值，结果失败了。 ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。 如何解决呢？ 具体解决方案，且看第(3)种更新策略的解析。
    4.先更新数据库，再删缓存
          首先，先说一下。老外提出了一个缓存更新套路，名为《Cache-Aside pattern》。其中就指出
          1、失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
          2、命中：应用程序从cache中取数据，取到后返回。
          3、更新：先把数据存到数据库中，成功后，再让缓存失效。
          另外，知名社交网站facebook也在论文《Scaling Memcache at Facebook》中提出，他们用的也是先更新数据库，再删缓存的策略。
          这种情况不存在并发问题么？
          不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生
          (1)缓存刚好失效
          (2)请求A查询数据库，得到一个旧值
          (3)请求B将新值写入数据库
          (4)请求B删除缓存
          (5)请求A将查到的旧值写入缓存。
        确实，如果发生上述情况，就一定会发生脏数据
        但是，实际发生这种情况的概率又有多少呢？
        发生上述情况有一个先天性条件，就是步骤（3）的写操作比步骤（2）的读操作耗时更短，才有可能使得步骤（4）先于步骤（5）。
        可是，我们想想，数据库的读操作的速度远快于写操作的(读写分离的意义不就是因为读操作比写操作块，消耗资源少)，因此步骤（3）耗时比步骤（2）还短，这一情景出现的概率真的很小，
        假设，非要解决这个隐患，一定要解决，怎么办？
        首先，给缓存设置有效时间是一种方案，其次，采用上面的异步延时删除策略，保证读请求完成后，再进行删除操作。
        思考还有其他造成不一致的原因吗？
        有的，这也是上述两种缓存更新策略都存在的一个问题，如果删除缓存失败怎么办，那不是会有不一致的情况出现么，比如一个写数据请求，然后写入数据库，删缓存失败了，这会不会就出现不一致的情况了，
        这也是缓存更新策略2里留下的最后一个疑问
        如何解决？？
        提供一个保障的重试机制即可，下面有两套方案
        1.更新数据路数据
          缓存因为种种问题删除失败
          将需要删除的key发送至消息队列
          自己消费消息，获得需要删除的key
          继续充实删除操作，直到成功，然而，该方案有一个缺点对业务线代码造成大量的侵入，于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，
          获得需要操作的数据，在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作
        2.流程如下所示：
          更新数据库数据
          数据库会将操作信息写入binlog日志中
          订阅程序提取所需要的数据以及key
          另起一段非业务代码，获得该信息
          尝试删除缓存操作，发现删除失败
          将这些信息发送至消息队列
          重新从消息队列中获得该数据，重新操作
          注意：上述的订阅binlog程序在mysql中有现成的中间件canal，可以完成订阅binlog日志的功能。另外，重试机制，主要采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可。  
